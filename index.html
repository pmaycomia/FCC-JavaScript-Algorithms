<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>FCC JavaScript Algorithms</title>
</head>

<body>
    <h1>FCC JavaScript Algorithms</h1>
    <h2>My Solutions:</h2>
    <ul>
        <li> <a href="#Basic"> Basic Algorithm Scripting </a> </li>
        <li><a href="#Intermediate"> Intermediate Algorithm Scripting </a></li>
        <li><a href="#Projects"> Algorithms and Data Structures Projects </a></li>
    </ul>
    <a id=Basic></a>
    <div>
        <h3>Basic Algorithm Scripting</h3>

        <ol>
            <li>Convert Celsius to Fahrenheit</li>
            <xmp>
                function convertToF(celsius) { 
                    let fahrenheit = (celsius * 9 / 5) + 32;
                    return fahrenheit;
                }
            </xmp>

            <li>Reverse a String</li>
            <xmp>
                function reverseString(str) {
                    let newStr = [];
                    newStr = str.split("").reverse().join(""); 
                    return newStr; 
                }
            </xmp>

            <li>Factorialize a Number</li>
            <xmp>
                function factorialize(num) {
                    if (num <=0 ) {
                         return 1; 
                    }
                    return num * factorialize(num - 1); 
                } 
                </xmp>

            <li>Find the Longest Word in a String</li>
            <xmp>
                function findLongestWordLength(str) { 
                    let newArr = str.split(" "); 
                    let result = 0; 
                    
                    for (let string of newArr) {
                         if (string.length > result) {
                              result = string.length;
                            }
                        };

                    return result; 
                }
            </xmp>            

            <li>Return Largest Numbers in Arrays</li>
            <xmp>
                function largestOfFour(arr) { 
                    let newArr = [];
                    for (let arrays of arr) {
                         newArr.push(Math.max(...arrays)) 
                    }
                    
                    return newArr; 
                }
            </xmp>

            <li>Confirm the Ending</li>
            <xmp>
                function confirmEnding(str, target) {
                    return str.slice(str.length - target.length) === target; 
                }
            </xmp>

            <li>Repeat a String Repeat a String</li>
            <xmp>
                function repeatStringNumTimes(str, num) { 
                    let newStr = ""; 
                    
                    for (let i = 0; i < num; i++) {
                            newStr=n ewStr.concat(str);
                    } 
                    return(newStr);
                }
            </xmp>

            <li>Truncate a StringPassed</li>
            <xmp>
                function truncateString(str, num) {
                     return str.length > num ? str.slice(0, num) + "..." : str; 
                }
            </xmp>

            <li>Finders Keepers</li>
            <xmp>
                function findElement(arr, func) {
                    let newArr = arr.map(func);
                    let res = 0; 
                    if(newArr.includes(true)) {
                        res = newArr.indexOf(true);
                        return arr[res]; 
                    } 
                }
            </xmp>

                            <li>Boo who</li>
                            <xmp>
                                function booWho(bool) { return typeof bool === "boolean" ? true : false }
                            </xmp>

                            <li>Title Case a Sentence</li>
                            <xmp>
                                function titleCase(str) { let newArr = str.toLowerCase().split(" "); for (let i = 0; i
                                < newArr.length; i++) { newArr[i]=n ewArr[i].charAt(0).toUpperCase() + newArr[i].substring(1); } return newArr.join( " "); } </xmp>

                                    <li>Slice and Splice</li>
                                    <xmp>
                                        function frankenSplice(arr1, arr2, n) { let copyArr2 = [...arr2]; let head = copyArr2.slice(0, n); let spliced = copyArr2.splice(n); let body = arr1.concat(spliced); return head.concat(body); }
                                    </xmp>

                                    <li>Falsy Bouncer</li>
                                    <xmp>
                                        function bouncer(arr) { let newArr = []; arr.map(obj => Boolean(obj) ? newArr.push(obj) : console.log(arr.indexOf(obj))) return newArr; }

                                    </xmp>

                                    <li>Where do I Belong</li>
                                    <xmp>
                                        function getIndexToIns(arr, num) { let newArr = arr.concat(num).sort(function(a, b){return a-b}); return newArr.indexOf(num); }
                                    </xmp>

                                    <li>Mutations</li>
                                    <xmp>
                                        function mutation(arr) { let newArr = []; for(let i = 0; i
                                        < arr[1].length; i++) { if (arr[0].toLowerCase().includes(arr[1][i].toLowerCase())){ newArr.push( "true"); } else { newArr.push( "false"); } } return newArr.includes( "false") ? false : true; } </xmp>

                                            <li>Chunky Monkey</li>
                                            <xmp>
                                                function chunkArrayInGroups(arr, size) { let newArr = []; while (arr.length > 0) { newArr.push(arr.splice(0, size)); } return newArr; }
                                            </xmp>
        </ol>


    </div>
    <a id=Intermediate></a>
    <div>
        <h3>Intermediate Algorithm Scripting</h3>
    </div>
    <ol>
        <li>Sum All Numbers in a Range</li>
        <xmp>
            function sumAll(arr) { 
                let sortAsc = function(a, b){return a-b}; 
                let reducer = function(acc, cval) {return acc + cval}; 
                let newArr = arr.sort(sortAsc); 
                for (let i = arr[0]; i < arr[1]; i++){ 
                    if (i !==a rr[0]) newArr.push(i);
                } 

                return newArr.sort(sortAsc).reduce(reducer);
            } 
            </xmp>

            <li>Diff Two Arrays</li>
            <xmp>
                function diffArray(arr1, arr2) { 
                    var a = [];
                    var b = [];
                    let newArr = []; 

                    if (arr1.length === 0) return arr2; 
                    if (arr2.length === 0) return arr1; 

                    for (let i of arr2) { 
                        a = arr1.filter(item => !arr2.includes(item));
                    } 

                    for (let j of arr1) { 
                        b = arr2.filter(item => !arr1.includes(item)); 
                    } 

                newArr = a.concat(b); 
                return newArr;
            }

            </xmp>    

            <li>Seek and Destroy</li>
            <xmp>
                function destroyer(...arr) { 
                    let mainArr = arr[0]; 
                    let toRemove = arr.slice(1) 
                    return mainArr.filter(item => !toRemove.includes(item); 
                }
            </xmp>

            <li>Wherefore art thou</li>
            <xmp style="background-color: brown;">
                function whatIsInAName(collection, source) { 
                    var arr = []; 
                    var keys = Object.keys(source); 
                    arr = collection.filter(function(object) {
                         for (let i = 0; i < keys.length; i++) { 
                             if (!object.hasOwnProperty(keys[i]) || object[keys[i]] !==s ource[keys[i]]) {
                                  return false; 
                            } 
                        } 
                        
                        return true; 
                    }); 
                        
                    return arr; 
                } 
            </xmp>
                        
                    
            <div class="spinal-case">
                <li>Spinal Tap Case</li>
                    <ul>
                        <li> Plan is to use regular expressions to split the string apart, then turn everything to lowercase, then add the dashes in between when joining them back.</li>
                        <li>Faced a problem with capital letters - the <em>split</em> function removes the letter. What to do? </li>
                        <li>Discovered <em> positive lookahead</em> to keep the capital letters.</li>
                        <li>Can't use <em>toLowerCase()</em> after splitting the string? Whyyyy?</li>
                        <li>Oh yeah, strings turn to an array when you split them. So join the words first, then turn everything to lower case. </li>
                    </ul>

                <xmp>
                    function spinalCase(str) { 
                        let regex = /\s|_|-|(?=[A-Z])/g;
                        
                        return str.split(regex).join("-").toLowerCase();
                        }
                </xmp>
                <xmp>
                    //PASTE THESE IN THE CONSOLE TO CHECK OUT THE ANSWERS!!! 
                    spinalCase('This Is Spinal Tap'); 
                    spinalCase("thisIsSpinalTap"); 
                    spinalCase("The_Andy_Griffith_Show"); 
                    spinalCase("Teletubbies say Eh-oh"); 
                    spinalCase("AllThe-small Things");
                </xmp>
            </div>

            <div class="pig-latin">
                <li>Pig Latin</li>
                <xmp>
                    function translatePigLatin(str) { 
                        let vowels = /a|e|i|o|u/i; 
                        let holder; 

                        if (str[0].match(vowels)) {
                             return  str.concat('way');
                        } else if (!str[0].match(vowels)) {
                            holder = str.split(/[a|e|i|o|u].?/i); 
                            return holder[0], str.substring(holder[0].length) + holder[0] + "ay"; 
                        } 
                    }
                </xmp>

                <xmp>
                    translatePigLatin("consonant"); 
                    translatePigLatin("california"); 
                    translatePigLatin("paragraphs"); 
                    translatePigLatin("glove"); 
                    translatePigLatin("eight"); 
                    translatePigLatin("schwartz"); 
                    translatePigLatin("schwartz");
                </xmp>

            </div>

            <li>Search and Replace</li>
            <xmp>
                function myReplace(str, before, after) { if (before[0] !== before[0].toLowerCase()) { console.log(str.replace(before, after[0].toUpperCase() + after.substring(1))); } else if (before[0] !== before[0].toUpperCase()) { return str.replace(before, after[0].toLowerCase()
                            + after.substring(1)); } return str.replace(before, after); }
            </xmp>
            <xmp>
                myReplace("He is Sleeping on the couch", "Sleeping", "sitting"); 
                myReplace("I think we should look up there", "up", "Down");
                 myReplace("His name is Tom", "Tom", "john"); 
                 myReplace("Let us get back to more Coding", "Coding", "algorithms"); 
                 myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");
            </xmp>
            
            <div class="dna-pairing">
            <li>DNA Pairing</li>
                <ul>
                    <li>I created the DNA object.</li>
                    <li>I did some test on the console first, I was wondering how I could access the objects. dna[0] gives undefined. So I tried putting the each letter and they work fine.</li>
                    <li>Then I thought this would be easy. A <em>for loop</em> would do the job.</li>
                    <li>Using the <em>push</em> method, the elements just placed them in one single array. By adding brackets [] in between the elements, push automatically added them as an array in an array. </li>
                </ul>
            <xmp>
                function pairElement(str) { 
                   let dna = { 
                        'G': 'C', 
                        'C': 'G', 
                        'A': 'T', 
                        'T': 'A' 
                    } 
    
                    let newArr = []; 
                    for (let i = 0; i < str.length; i++) {
                        newArr.push([str[i], dna[str[i]]]) 
                    } 
                    
                    return newArr;
                } 
            </xmp>
            
            <xmp>
                pairElement("GCG");
                pairElement("ATCGA"); 
                pairElement("TTGAG"); 
                pairElement("CTCTA");
            </xmp>
        </div>

        <div class="missing-letters">
                            
            <li>Missing Letters</li>
            
            <ul>
            
                <li>I was planning to create an alphabet object, I tried it for the first example but it's too complicated. So I thought I'll just use <em>fromCharCode and charCodeAt</em>. I'm not so familiar with these methods so I was a
                                    little scared to use them but I realized in the end that they aren't actually that had to use.
                </li>
            
                        <li>First, I played with the characters in the console. charCodeAt returns the code of the characters, and you'll find the anomally if the character code jumped more than 1.</li>
                                <li>I made an <em>if</em> statement with an argument of "If charcodeat[n] minus charcodeat(first char) is not equal to 1, then that is the anomally.</li>
                                <li>Then I put the if statement in a loop!</li>
                                <li>If argument is true, we return the character from last element minus 1.</li>
                            </ul>
                            <xmp>
                                function fearNotLetter(str) { let base = str.charCodeAt(0); for (let i = 1; i
                                < str.length; i++) { if(str.charCodeAt(i) - base !==i ) { return String.fromCharCode(str.charCodeAt(i) - 1); } } } </xmp>
                                    <xmp>
                                        fearNotLetter("abce"); fearNotLetter("abcdefghjklmno"); fearNotLetter("stvwx"); fearNotLetter("stvwx"); fearNotLetter("bcdf"); fearNotLetter("abcdefghijklmnopqrstuvwxyz");
                                    </xmp>
                        </div>

                        <div class="sorted-union">
                            <li>Sorted Union</li>
                            <xmp>
                                function uniteUnique(...arr) { let newArr = []; for (let n = 0; n
                                < arr.length; n++) { for (let m=0 ; m < arr[n].length; m++) { if (!newArr.includes(arr[n][m])) { newArr.push(arr[n][m]) } } } return newArr; } </xmp>

                                    <xmp>
                                        uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]); uniteUnique([1, 2, 3], [5, 2, 1]); uniteUnique([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8]);
                                    </xmp>
                        </div>



                        <div class="convert-html">
                            <li>Convert HTML Entities</li>
                            <ul>
                                <li>First, I created an object with all the HTML entities.</li>
                                <li>I tried a for loop to check if the character of the string matches any entity in the object, but as soon as it gets the first match, it stops and the second special character won't be matched and replaced.</li>
                                <li>It took me an hour to solve this algotrithm and that is because I didn't know we can create function as the second argument of replace, as soon as you know that, this would be easy.</li>
                            </ul>
                            <xmp>
                                function convertHTML(str) { let entities = { "&": "&amp;", "
                                < ": "&lt; ",
                          ">": "&gt;", "\"": "&quot;", "'": "&apos;" }; return str.replace(/([&
                                    <>\"'])/g, char => entities[char]); }
                            </xmp>
                            <xmp>
                                convertHTML("Dolce & Gabbana"); convertHTML("Hamburgers
                                < Pizza < Tacos ");
                    convertHTML("Sixty> twelve"); convertHTML('Stuff in "quotation marks"'); convertHTML("Schindler's List"); convertHTML("
                                    <>"); convertHTML("abc");
                            </xmp>
                        </div>



                        <li>Sum All Odd Fibonacci Numbers</li>
                        <xmp>
                            function sumFibs(num) { return num; } sumFibs(4);
                        </xmp>
                        <h2>recursion maybe?</h2>

                        <li>Sum All Primes</li>
                        <xmp>

                        </xmp>

                        <li>Smallest Common Multiple</li>
                        <xmp>

                        </xmp>

                        <li>Drop it</li>
                        <xmp>

                        </xmp>

                        <li>Streamroller</li>
                        <p>Would be awesome if I could implement a for loop to distinguish if there is still a bracket inside the array, to reduce the code.</p>
                        <xmp>
                            function steamrollArray(arr) { let firstHolder = arr.reduce((acc, el) => acc.concat(el), []); let secondHolder = firstHolder.reduce((acc, el) => acc.concat(el), []) let thirdHolder = secondHolder.reduce((acc, el) => acc.concat(el), []) return thirdHolder;
                            }

                        </xmp>
                        <xmp>
                            steamrollArray([1, [2], [3, [[4]]]]); steamrollArray([[["a"]], [["b"]]]); steamrollArray([1, [], [3, [[4]]]]); steamrollArray([1, {}, [3, [[4]]]]) ;
                        </xmp>

                        <li>Binary Agents</li>
                        <p>Capital A in ascii is 65, in binary "01000001"</p>
                        <p>convert binary to decimal then convert to ascii using fromCharCode</p>
                        <xmp>
                            function binaryAgent(str) { let newArr = str.split(" "); let newStr = ""; let char= ""; let result = []; for (let elem of newArr) { let binaryToDigit = parseInt(elem, 2); char = newStr.concat("", String.fromCharCode(binaryToDigit)); result.push(char);
                            } return result.join(''); 
                        }

                        </xmp>

                        <xmp>
                            binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
                            binaryAgent("01001001 00100000 01101100 01101111
                            01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001");
                        </xmp>

                        <li>Everything Be True</li>
                        <xmp>
                            function truthCheck(collection, pre) {
                                let checker = 0; 
                                for (let i = 0; i < collection.length; i++) {
                                    let selection=c ollection[i][pre]; 
                                    if(!selection) checker +=1;
                                    else checker +=0;
                                }
                                
                                if (checker===0 ) return true;
                                else return false; 
                            } 
                        </xmp>

                                <li>Arguments Optional</li>
                                <xmp>

                                </xmp>

        <li>Make a Person</li>
        <xmp>   
            var Person = function(firstAndLast) {              
                let fullName = firstAndLast;
              
                this.getFullName = function() {
                  return fullName
                };
              
                this.getFirstName = function() {
                  return fullName.split(" ")[0]
                }
              
                this.getLastName = function() {
                  return fullName.split(" ")[1]
                }              
              
                this.setFirstName = function (first) {
                  fullName = first + " " + fullName.split(" ")[1];
                }
              
                this.setLastName = function (last) {
                  fullName = fullName.split(" ")[0] + " " + last;
                }
              
                this.setFullName = function (full) {
                  return fullName = full;
                }
              
                return firstAndLast;                
              };

        </xmp>

                                <li>Map the Debris</li>
                                <xmp>

                                </xmp>


    </ol>

    <a id=Projects></a>
    <div>
        <h3>Algorithms and Data Structures Projects</h3>
        <ol>
            <li>Palindrome Checker/li>
                <xmp>

                </xmp>

                <li>Roman Numeral Converter</li>
                <xmp>

                </xmp>

                <li>Caesars Cipher</li>
                <xmp>
                    function rot13(str) { let newArr = []; let arrOfStr = str.split(" ") let newArrOfStr = [] let temp = "" let wordHolder = "" for (let i = 0; i
                    < arrOfStr.length; i++) { for (let j=0 ; j < arrOfStr[i].length; j++) { newArr.pop() if(arrOfStr[i].charCodeAt(j) < 78 && arrOfStr[i].charCodeAt(j)> 64) { temp = String.fromCharCode(arrOfStr[i].charCodeAt(j) + 13) } else if (arrOfStr[i].charCodeAt(j) > 77 && arrOfStr[i].charCodeAt(j)
                        < 91) { temp=S tring.fromCharCode(arrOfStr[i].charCodeAt(j) - 13) } else { temp=a rrOfStr[i][j] } newArrOfStr.push(temp) } newArrOfStr.push( " ") wordHolder=n ewArrOfStr.join( "") newArr.push(wordHolder) } console.log(newArr.toString().trim()) return
                            newArr.toString().trim(); } //UPDATE: FIGURED OUT REASON FOR PREVIOUS ERRIOR, THERE WERE SPACES AFTER THE STRING SO I USED TRIM TO SOLVE IT //i 've got the output correctly but FCC won't accept my solution //typeof final string
                            is string //i will sleep on it for now and look at it again tom //and clean up the code too!!! </xmp>
                            <h5>get char's unicode, map all string and add 13</h5>
                            <li>Telephone Number Validator</li>
                            <xmp>

                            </xmp>

                            <li>Cash Register</li>
                            <xmp>

                            </xmp>

        </ol>
    </div>

    <script src="script.js"></script>
</body>

</html>